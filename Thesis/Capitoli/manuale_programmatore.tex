In questo capitolo sono inserite tutte le informazioni necessarie per chiunque voglia modificare la struttura del gioco, aggiungendo livelli, minacce, messaggi e quant'altro. Nella prima parte è esposta la modalità di installazione del gioco, in modo da riuscire ad eseguirlo in locale con fini di sviluppo \ref{sec:howto}. Successivamente, nei paragrafi \ref{sec:noncodecontents}, \ref{sec:classes} e \ref{sec:prefabs} sono fornite informazioni riguardo sia i file di codice che non, utilizzati all'interno del gioco e su cui eventualmente agire per apportare modifiche riguardo la logica del gameplay. In \ref{sec:folderstructure} è mostrata la struttura delle cartelle di gioco, esposta così come appare all'interno dell'editor di Unity. Infine, nell'ultima sezione (\ref{sec:addlevel}) è esposto come è possibile aggiungere dei livelli al gioco.

\section{Guida d'installazione}\label{sec:howto}

Il gioco, al momento della stesura di questo report, non è da installare ed è disponibile all'indirizzo \url{http://simscada.sfcoding.com/SIMSCADA/}. Se il sito di hosting non dovesse essere più raggiungibile, è possibile eseguirne una versione in un server locale. Questo può essere utile anche per effettuare test in caso di modifiche del codice di controllo, aggiunte di livelli e così via. Per far sì che il gioco funzioni in locale, però, sono necessari alcuni passaggi.

\begin{description}

\item[Installazione di un server di gioco] Per eseguire il gioco, è sufficiente avere un web server Apache installato sulla propria macchina e copiare i file prodotti da Unity al momento della build, ossia il contenuto delle cartelle \code{Build} e \code{TemplateData}, più il file \code{index.html}, all'interno della cartella \code{htdocs} del server. Esistono diversi metodi per installare un server Apache, a seconda anche del sistema operativo su cui si sta lavorando, ma una soluzione veloce, semplice e soprattutto valida per tutti i casi è quella fornita dal software \code{XAMPP}. 

Questo software, disponibile al link \url{https://www.apachefriends.org/it/download.html}, è disponibile per Windows, MacOS e Linux e permette di installare velocemente tutte le componenti necessarie per eseguire un web server sulla propria macchina in locale. 

Una volta terminata la procedura d'installazione di \code{XAMPP}, sarà necessario individuare la cartella dove sono stati salvati i file. Normalmente, quelle predefinite sono:

\begin{description}

\item[Windows:] C:/xampp

\item[Linux:]  /opt/xampp

\item[MacOS:]  /Applications/XAMPP/xamppfiles

\end{description}

\item[Creazione della cartella di gioco] Trovata la cartella di installazione di \code{XAMPP}, sarà necessario individuare la cartella\code{htdocs}. Al suo interno è consigliato creare un'ulteriore cartella, denominata ad esempio \code{SIMSCADA}. Qui dovranno essere copiati tutti i file prodotti da Unity al momento della build.

\item[Download del progetto] Tutti i file del progetto Unity sono salvati nella repository GitHub raggiungibile all'indirzzo \url{https://github.com/serranda/SecuritySeriousGame}. È possibile ottenerne una copia sia utilizzando il comando \code{git clone https://github.com/serranda/\\SecuritySeriousGame} (per utilizzare questo comando è necessario installare il client Git nel proprio sistema, per questo passaggio si rimanda alle guida ufficiali presenti nel sito di Git, \url{https://git-scm.com/downloads}), ma anche tramite il pulsante download presente nella pagina della repository ( in questo caso verrà effettuato il download di un file .zip. Una volta ottenuta, sarà necessario estrarne il contenuto)

\item[Installazione di Unity] Per installare l'editor di Unity sul proprio sistema, il modo più semplice è quello di utilizzare lo Unity Hub creato per aiutare nella gestione delle installazioni e dei progetti creati con l'editor. Questo programma può essere ottenuto vistando il forum ufficiale al link \url{https://forum.unity.com/threads/unity-hub-v2-0-0-release.677485/}. Una volta installato Unity Hub, è possibile scegliere la versione dell'editor che si vuole installare. Per questo progetto è consigliato utilizzare le versioni 2018.4.x LTS, in quanto sono quelle che garantiscono la compatibilità con tutti i file del progetto. Versioni precedenti non sono utilizzabili, mentre per quanto riguarda quelle successive non se ne garantisce il corretto funzionamento con il progetto intero.
Al momento dell'installazione dell'editor è importante selezionare di voler installare anche il modulo aggiuntivo denominato \code{WebGL Build Support}, con cui sarà possibile creare la build effettiva del gioco.
Una volta installato l'editor, è possibile importarvi al suo interno i file del progetto, contenuti all'interno della cartella \code{SIMSCADA}.

\item[Creazione della build] Una volta importati i file del progetto, è possibile aprirlo all'interno dell'editor. Se si vogliono apportare delle modifiche, è possibile farlo. Una volta terminate, è necessario creare la build finale, da caricare successivamente nel server locale creato tramite XAMPP. Per fare ciò, bisogna selezionare la voce \code{Build Settings}, contenuta all'interno del tab \cmd{File}. A questo punto si aprirà una finestra in cui sarà necessario impostare quali scene si vogliono includere nella build finale e per quale piattaforma effettuarla. Occorrerà quindi selezionare la piattaforma WebGL dal menù posto sulla sinistra della finestra e premere sul tasto \code{Build}. A questo punto, dopo aver scelto la cartella all'interno di cui verranno generati tutti i file, la compilazione inizierà e sarà necessario attenderne il termine.

\item[Copia della build nel server] Terminata la compilazione, è possibile prenderne il contenuto e spostarlo all'interno della cartella \code{SIMSCADA}, creata precedentemente nella directory \code{htdocs} di \code{XAMPP}. È necessario, inoltre, spostare anche la cartella \code{PHP} (situata all'interno della directory del progetto ottenuta tramite GitHub), contenente i file degli script PHP necessari per eseguire operazioni sul server. Una volta eseguite queste azioni è possibile utilizzare un qualsiasi web browser che supporti l'utilizzo di WebGL (per controllare che il proprio browser supporti l'esecuzione di applicazioni WebGL è possibile collegarsi al sito \url{https://get.webgl.org/} ed effettuare il test ) e collegarsi all'indirizzo \url{localhost/SIMSCADA/}. Il gioco partirà non appena terminato il caricamento della pagina.

\end{description}

\section{Contenuti del gioco senza codice}\label{sec:noncodecontents}

Diverse risorse del gioco sono definite attraverso file di testo e json in modo da agevolare le operazioni di gestione durante la partita e/o eventuali loro modifiche durante lo sviluppo. Questi file sono contenuti all'interno della cartella \code{Resources} della directory del progetto. Questo si è reso necessario in modo da poter sfruttare i metodi della classe \code{Resources} e caricare velocemente il contenuto dei file all'interno del gioco. Di seguito saranno descritte le strutture di queste risorse più nel dettaglio. 

Di queste risorse sono stati creati anche dei template a cui far riferimento, nel caso in cui se ne voglia aggiungere di nuovi. Questi sono situati sempre nella directory del progetto Unity.

\subsection{Messages}

All'interno del gioco sono presenti diversi messaggi di sistema rivolti all'utente, in modo da informarlo sugli avvenimenti della partita, se sta commettendo qualche azione errata o, ancora, per fornire dei suggerimenti. Vi sono poi i messaggi del tutorial, tramite cui si danno al giocatore le informazioni necessarie per apprendere le dinamiche basilari del gameplay. Ognuno di questi messaggi è creato partendo dal contenuto di due file, un file json ed un file txt.

Nel file json sono contenuti i valori delle proprietà della classe con cui si definiscono i messaggi all'interno del codice (un esempio di file json di questo genere è mostrao nella figura \ref{fig:dialogboxmessagejson}). La classe è stata denominata \code{DialogBoxMessage} ed il suo contenuto è riportato nella figura \ref{fig:dialogboxmessageclass}.

Come è possibile vedere, un oggetto della classe \code{DialogBoxMessage} è composto da cinque proprietà. Le prime quattro 4 sono fornite dal file json e sono:

\begin{itemize}

\item \code{head}, ossia il testo riportato nel titolo del messaggio;

\item \code{bodyPath}, ossia il percorso dove è salvato il testo del messaggio;

\item \code{backBtn}, ossia il testo che viene riportato in uno dei due pulsanti con cui il giocatore può interagire (usualmente con questo valore si vuole indicare il pulsante che permette di tornare indietro o annullare un'eventuale azione proposta dal sistema);

\item \code{nextBtn}, ossia il testo che viene riportato nell'altro pulsante (con questo valore, al contrario, si vuole indicare il pulsante che permette procedere con l'azione proposta dal gioco).

\end{itemize}

Queste proprietà sono assegnate durante la creazione dell'oggetto, resa possibile grazie al metodo \code{FromJson} della classe \code{JsonUtility}, messa a disposizione dalle API di Unity (\ref{fig:jsonutility}).

La quinta proprietà, \code{body}, come si può vedere la codice della classe riportato in figura \ref{fig:dialogboxmessageclass}, viene creata automaticamente a partire dalla proprietà \code{bodyPath}. Come anticipato, \code{bodyPath} contiene il valore del percorso in cui è salvato il file txt in cui è riportato il testo completo del messaggio. È stato deciso, infatti, di non inserire l'intero contenuto del messaggio nel file json, ma di salvarlo in un file a parte, tenendo nota però della sua posizione (relativa al working tree del progetto di Unity).

Questa strategia, applicata anche per i file delle \code{Lesson} (come si vedrà successivamente in \ref{sec:lessons}) è stata ideata per evitare di incappare in errori durante la fase di deserializzazione del file json. In questo modo, inoltre, è possibile modificare il contenuto del messaggio con un qualsiasi editor di testo (è importante che la codifica del file txt sia impostata in \code{UTF-8}, altrimenti l'editor di Unity non riconsocerà il contenuto e darà un errore al momento della creazione dell'oggetto) senza dover cambiare la struttura del file json.

\begin{figure}[tb]
\HRule
\begin{lstlisting}
{
	"head": <MessageHead>,
	"bodyPath": <MessageBodyPath>,
	"backBtn": <MessageBackBtn>,
	"nextBtn": <MessageNextBtn>
}
\end{lstlisting}
\HRule
\caption{Contenuto del file json da cui sono estratte le proprietà della classe \code{DialogBoxMessage}.\label{fig:dialogboxmessagejson}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
using UnityEngine;

public class DialogBoxMessage
{
    public string head;
    public string bodyPath;
    public string backBtn;
    public string nextBtn;

    public string body =>
        string.IsNullOrEmpty(bodyPath) 
            ? string.Empty 
            : Resources.Load<TextAsset>(bodyPath).text;
}
\end{lstlisting}
\HRule
\caption{Contenuto della classe \code{DialogBoxMessage}.\label{fig:dialogboxmessageclass}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
DialogBoxMessage dialogBoxMessage = JsonUtility.FromJson<DialogBoxMessage>(jsonFile.text);
\end{lstlisting}
\HRule
\caption{Codice tramite cui sono creati gli oggetti della classe \code{DialogBoxMessage}.\label{fig:jsonutility}}
\end{figure}

\subsection{Lesson}\label{sec:lessons}

Anche per le lezioni è stato utilizzato un approccio simile a quello visto per i \code{DialogBoxMessage}. In questo caso le proprietà definite per la classe sono solamente tre (\ref{fig:lessonclass}), di cui quelle riportate nel file json sono \code{id} e \code{textPath} (\ref{fig:lessonjson}).

Come nel caso dei \code{DialogBoxMessage}, anche il testo delle \code{Lesson} è salvato in un file di testo a parte, la cui posizione è memorizzata con la proprietà \code{textPath}. Questa verrà poi utilizzata per generare, al momento della creazione dell'oggetto, il valore della proprietà \code{textBody}. 

L'altra proprietà, \code{id}, è utilizzata per identificare l'argomento associato alla lezione in questione. Il suo valore, inoltre, è impiegato per rinominare i pulsanti tramite cui è possibile selezionare la lezione a cui si vuole accedere (\ref{fig:notebookImage})

\begin{figure}[tb]
\HRule
\begin{lstlisting}
{
  "id":"LessonID",
  "textPath":"LessonBodyPath"
}
\end{lstlisting}
\HRule
\caption{Contenuto del file json da cui sono estratte le proprietà della classe \code{Lesson}.\label{fig:lessonjson}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
using UnityEngine;

public class Lesson
{
    public string id;
    public string textPath;

    public string textBody =>
        string.IsNullOrEmpty(textPath)
            ? string.Empty
            : Resources.Load<TextAsset>("LessonsBody/" + textPath + "_IT").text;
}
\end{lstlisting}
\HRule
\caption{Contenuto della classe \code{Lesson}.\label{fig:lessonclass}}
\end{figure}

\begin{figure}
\centerline{\includegraphics[scale=0.4]{Immagini/notebookImage}}
\caption{ Screenshot del quaderno presente nel gioco, tramite cui è possibile accedere alle \code{Lesson}. Sulla destra sono visibili i pulsanti, raffigurati come dei segnalibri, che permettono la visualizzazione del testo inerente alla \code{Lesson} desiderata. }\label{fig:notebookImage}
\end{figure}

\subsection{ItemStore}

\section{Classi}\label{sec:classes}

\section{Prefab}\label{sec:prefabs}

\section{Struttura delle cartelle}\label{sec:folderstructure}

\section{Come aggiungere un livello}\label{sec:addlevel}