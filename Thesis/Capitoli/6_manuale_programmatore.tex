In questo capitolo sono inserite tutte le informazioni necessarie per chiunque voglia modificare la struttura del gioco, aggiungendo livelli, minacce, messaggi e quant'altro. Nei paragrafi \ref{sec:noncodecontents} e \ref{sec:classes} sono fornite informazioni riguardo sia i file di codice che non, utilizzati all'interno del gioco e su cui agire per apportare modifiche riguardo la logica del gameplay. Nell'ultima sezione (\ref{sec:addlevel}) è esposto come è possibile aggiungere dei livelli al gioco. 

Prima di iniziare ad esporre il contenuto delle sezioni presentate, è necessaria una premessa. Poiché SimSCADA fa utilizzo di tecnologie WebGL, il gioco, al momento della stesura di questo report, non necessita di alcuna installazione e per eseguirlo è sufficiente collegarsi all'indirizzo \url{http://simscada.sfcoding.com/SIMSCADA/}. Se il sito di hosting non dovesse essere più raggiungibile, è possibile eseguirne una versione in un server locale. Questo può essere utile anche per effettuare test in caso di modifiche del codice di controllo, aggiunte di livelli e così via. Per far sì che il gioco funzioni in locale, però, sono necessari alcuni passaggi, esposti nell'appendice \ref{sec:howto}.

\section{Contenuti del gioco senza codice}\label{sec:noncodecontents}

Diverse risorse del gioco sono definite attraverso file di testo e json in modo da agevolare le operazioni di gestione durante la partita e/o eventuali loro modifiche durante lo sviluppo. Questi file sono contenuti all'interno della cartella \code{Resources} della directory del progetto. Questo si è reso necessario in modo da poter sfruttare i metodi della classe \code{Resources} e caricare velocemente il contenuto dei file all'interno del gioco. Di seguito saranno descritte le strutture di queste risorse più nel dettaglio. 

Di queste risorse sono stati creati anche dei template a cui far riferimento, nel caso in cui se ne voglia aggiungere di nuovi. Questi sono situati sempre nella directory del progetto Unity.

\subsection{Messages}

All'interno del gioco sono presenti diversi messaggi di sistema rivolti all'utente, in modo da informarlo sugli avvenimenti della partita, se sta commettendo qualche azione errata o, ancora, per fornire dei suggerimenti. Vi sono poi i messaggi del tutorial, tramite cui si danno al giocatore le informazioni necessarie per apprendere le dinamiche basilari del gameplay. Ognuno di questi messaggi è creato partendo dal contenuto di due file, un file json ed un file txt.

Nel file json sono contenuti i valori delle proprietà della classe con cui si definiscono i messaggi all'interno del codice (un esempio di file json di questo genere è mostrao nella figura \ref{fig:dialogboxmessagejson}). La classe è stata denominata \code{DialogBoxMessage} ed il suo contenuto è riportato nella figura \ref{fig:dialogboxmessageclass}.

Come è possibile vedere, un oggetto della classe \code{DialogBoxMessage} è composto da cinque proprietà. Le prime quattro 4 sono fornite dal file json e sono:

\begin{itemize}

\item \code{head}, ossia il testo riportato nel titolo del messaggio;

\item \code{bodyPath}, ossia il percorso dove è salvato il testo del messaggio;

\item \code{backBtn}, ossia il testo che viene riportato in uno dei due pulsanti con cui il giocatore può interagire (usualmente con questo valore si vuole indicare il pulsante che permette di tornare indietro o annullare un'eventuale azione proposta dal sistema);

\item \code{nextBtn}, ossia il testo che viene riportato nell'altro pulsante (con questo valore, al contrario, si vuole indicare il pulsante che permette procedere con l'azione proposta dal gioco).

\end{itemize}

Queste proprietà sono assegnate durante la creazione dell'oggetto, resa possibile grazie al metodo \code{FromJson} della classe \code{JsonUtility}, messa a disposizione dalle API di Unity (\ref{fig:jsonutility}).

La quinta proprietà, \code{body}, come si può vedere la codice della classe riportato in figura \ref{fig:dialogboxmessageclass}, viene creata automaticamente a partire dalla proprietà \code{bodyPath}. Come anticipato, \code{bodyPath} contiene il valore del percorso in cui è salvato il file txt in cui è riportato il testo completo del messaggio. È stato deciso, infatti, di non inserire l'intero contenuto del messaggio nel file json, ma di salvarlo in un file a parte, tenendo nota però della sua posizione (relativa al working tree del progetto di Unity).

Questa strategia, applicata anche per i file delle \code{Lesson} (come si vedrà successivamente in \ref{sec:lessons}) è stata ideata per evitare di incappare in errori durante la fase di deserializzazione del file json. In questo modo, inoltre, è possibile modificare il contenuto del messaggio con un qualsiasi editor di testo (è importante che la codifica del file txt sia impostata in \code{UTF-8}, altrimenti l'editor di Unity non riconsocerà il contenuto e darà un errore al momento della creazione dell'oggetto) senza dover cambiare la struttura del file json.

\begin{figure}[tb]
\HRule
\begin{lstlisting}
{
	"head": <MessageHead>,
	"bodyPath": <MessageBodyPath>,
	"backBtn": <MessageBackBtn>,
	"nextBtn": <MessageNextBtn>
}
\end{lstlisting}
\HRule
\caption{Contenuto del file json da cui sono estratte le proprietà della classe \code{DialogBoxMessage}.\label{fig:dialogboxmessagejson}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
using UnityEngine;

public class DialogBoxMessage
{
    public string head;
    public string bodyPath;
    public string backBtn;
    public string nextBtn;

    public string body =>
        string.IsNullOrEmpty(bodyPath) 
            ? string.Empty 
            : Resources.Load<TextAsset>(bodyPath).text;
}
\end{lstlisting}
\HRule
\caption{Contenuto della classe \code{DialogBoxMessage}.\label{fig:dialogboxmessageclass}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
DialogBoxMessage dialogBoxMessage = JsonUtility.FromJson<DialogBoxMessage>(jsonFile.text);
\end{lstlisting}
\HRule
\caption{Codice tramite cui sono creati gli oggetti della classe \code{DialogBoxMessage}.\label{fig:jsonutility}}
\end{figure}

\subsection{Lesson}\label{sec:lessons}

Anche per le lezioni è stato utilizzato un approccio simile a quello visto per i \code{DialogBoxMessage}. In questo caso le proprietà definite per la classe sono solamente tre (\ref{fig:lessonclass}), di cui quelle riportate nel file json sono \code{id} e \code{textPath} (\ref{fig:lessonjson}).

Come nel caso dei \code{DialogBoxMessage}, anche il testo delle \code{Lesson} è salvato in un file di testo a parte, la cui posizione è memorizzata con la proprietà \code{textPath}. Questa verrà poi utilizzata per generare, al momento della creazione dell'oggetto, il valore della proprietà \code{textBody}. 

L'altra proprietà, \code{id}, è utilizzata per identificare l'argomento associato alla lezione in questione. Il suo valore, inoltre, è impiegato per rinominare i pulsanti tramite cui è possibile selezionare la lezione a cui si vuole accedere (\ref{fig:notebookImage})

\begin{figure}[tb]
\HRule
\begin{lstlisting}
{
  "id":"LessonID",
  "textPath":"LessonBodyPath"
}
\end{lstlisting}
\HRule
\caption{Contenuto del file json da cui sono estratte le proprietà della classe \code{Lesson}.\label{fig:lessonjson}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
using UnityEngine;

public class Lesson
{
    public string id;
    public string textPath;

    public string textBody =>
        string.IsNullOrEmpty(textPath)
            ? string.Empty
            : Resources.Load<TextAsset>("LessonsBody/" + textPath + "_IT").text;
}
\end{lstlisting}
\HRule
\caption{Contenuto della classe \code{Lesson}.\label{fig:lessonclass}}
\end{figure}

\begin{figure}
\centerline{\includegraphics[scale=0.3]{Immagini/notebookImage}}
\caption{ Screenshot del quaderno presente nel gioco, tramite cui è possibile accedere alle \code{Lesson}. Sulla destra sono visibili i pulsanti, raffigurati come dei segnalibri, tramite cui è possibile acceder al testo inerente alla \code{Lesson} desiderata.\label{fig:notebookImage}}
\end{figure}

\subsection{ItemStore}\label{sec:itemstore}

\code{ItemStore} è la classe tramite cui sono definiti gli oggetti acquistabili tramite il negozio. L'approccio è lo stesso utilizzato per gli altri oggetti e sfrutta, come visto, un file json per creare l'oggetto della classe \code{ItemStore} e un file txt contenente la descrizione dell'oggetto da visualizzare nel gioco. Gli \code{ItemStore}, però, posseggono ulteriori proprietà (figure \ref{fig:itemstorejson} e \ref{fig:itemstoreclass}), qui di seguito analizzate:

\begin{itemize}

\item \code{name}, ossia il nome con cui è identificato un oggetto. Al momento della creazione della lista di \code{ItemStore}, è la proprietà utilizzata per ordinare la collezione di oggetti. Questo è possibile grazie all'implementazione di un classe a parte, \code{NameRelationalComparer}. Questa è una classe, derivata dall'interfaccia \code{IComparer<T>}, esposta tramite l'utilizzo di una proprietà statica (\ref{fig:namerelationalcomparer}), che permette di ordinare una lista di \code{ItemStore} tramite il metodo \code{List<T>.Sort} (\ref{fig:listsort}). Per il caso in questione è stata scelta come termine di paragone il solo nome dell'oggetto, mo ovviamente è possibile implementare altre classi che tengano conto di più proprietà;

\item \code{descriptionPath}, stringa tramite cui è memorizzato il percorso di salvataggio del fil txt contenete la descrizione dell'oggetto;

\item \code{imageName}, stringa contenete il nome dell'immagine associata all'oggetto. L'immagine, successivamente, verrà caricata sempre tramite la classe \code{Resources}. Questa proprietà, attualmente, non è ancora utilizzata, ma lo sarà in un possibile futuro sviluppo del gioco (si rimanda alla sezione \ref{sec:futuredevelop});
 
\item \code{price}, valore tramite cui è impostato il prezzo iniziale dell'oggetto. Ad ogni acquisto subirà un incrementato del 10\%. La modifica del prezzo non è memorizzata nel file json originale, si rimanda alla sezione \ref{sec:gamesaves} per ulteriori spiegazioni;

\item \code{finalLevel}, ossia il valore del livello finale a cui può arrivare un oggetto dopo essere stato potenziato al massimo. Per alcune tipologie di oggetti, come ad esempio la campagna di assunzione per aumentare il numero di dipendenti dell'azienda, non è previsto un limite di livello. In questo caso il valore della proprietà sarà di -1;

\item \code{currentLevel}, il livello di potenziamento a cui si trova attualmente l'oggetto. Il valore di partenza è 0 ed è aumentato ad ogni acquisto, a meno che non si tratti di oggetti senza limite di potenziamento, nel cui caso rimarrà fisso al valore iniziale;

\item \code{effect}, il valore tramite cui è identificato quale effetto produce l'acquisto dell'oggetto. Ad ogni oggetto è assegnato un valore univoco di questa proprietà. L'applicazione dell'effetto è gestita tramite l'utilizzo di uno statement \code{switch} che, in base al valore assegnato all'effetto, esegue il codice associato al \code{case} corrispondente;

\item \code{itemObject}, ossia l'istanza del \code{GameObject} associato ad un \code{ItemStore}. Questa proprietà non viene sfruttata in fase di creazione dell'oggetto, ma è in realtà necessaria per permettere la corretta memorizzazione degli \code{ItemStore} durante la fase di salvataggio. Per approfondimenti si rimanda alla sezione \ref{sec:gamesaves};

\item \code{threatAffinity}, ossia una lista contenente i tipi di minaccia contro di cui l'\code{ItemStore} in questione garantisce protezione. Questa proprietà è utilizzata durante la fase di analisi delle performance del giocatore (si rimanda alla sezione \ref{sec:analysis}).
\end{itemize}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
{
	"name": "",
	"descriptionPath": "",
	"imageName": "",
	"price": 0,
	"finalLevel": 0,
	"currentLevel" :  0,
	"effect" : 0,	
	"itemObject" :  {},
	"threatAffinity" : []
}
\end{lstlisting}
\HRule
\caption{Contenuto del file json da cui sono estratte le proprietà della classe \code{ItemStore}.\label{fig:itemstorejson}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
using System;
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class ItemStore
{
    public string name;
    public string descriptionPath;

    public string descriptionBody =>
        string.IsNullOrEmpty(descriptionPath)
            ? string.Empty
            : Resources.Load<TextAsset>("ItemStoreBody/"+descriptionPath + "_IT").text;

    //public string imageName;
    public int price;
    public int finalLevel;
    public int effect;
    public int currentLevel;
    public GameObject itemObject;
    public List<string> threatAffinity;
}
\end{lstlisting}
\HRule
\caption{Contenuto della classe \code{ItemStore}.\label{fig:itemstoreclass}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
private sealed class NameRelationalComparer : IComparer<ItemStore>
{
    public int Compare(ItemStore x, ItemStore y)
    {
        if (ReferenceEquals(x, y)) return 0;
        if (ReferenceEquals(null, y)) return 1;
        if (ReferenceEquals(null, x)) return -1;
        return string.Compare(x.name, y.name, StringComparison.Ordinal);
    }
}

public static IComparer<ItemStore> nameComparer { get; } = new NameRelationalComparer();
\end{lstlisting}
\HRule
\caption{Definizione della classe \code{NameRelationalComparer} derivata dall'interfaccia \code{IComparer<T>}.\label{fig:namerelationalcomparer}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
//POPULATE ITEMLIST
if (itemList.Count == 0)
{
    foreach (TextAsset textAsset in itemAsset)
    {
        ItemStore itemStore = ItemStoreFromJson(textAsset);
        itemList.Add(itemStore);
    }
}

//SORT ITEMLIST
itemList.Sort(ItemStore.nameComparer);
\end{lstlisting}
\HRule
\caption{Creazione della lista di \code{ItemStore} e successivo ordinamento tramite il metodo \code{List<T>.Sort}.\label{fig:listsort}}
\end{figure}

\section{Classi e script di controllo} \label{sec:classes}

La programmazione di un'applicazione tramite Unity si basa sull'utilizzo di script di codice, eventualmente associabili a dei \code{GameObject}, che vengono eseguiti durante il gioco. Questo è possibile tramite le varie funzioni delle API messe a disposizione da Unity. Per l'elenco completo di tutte le funzioni si rimanda al manuale disponibile al link \url{https://docs.unity3d.com/ScriptReference/index.html}. È comunque possibile accedere tramite l'editor ad una copia di questo manuale, specifica per la versione di Unity che si sta utilizzando: è sufficiente aprire il tab \code{Help} e fare click sulla voce \code{Scripting Reference}.

Tutti gli script creati con Unity devono derivare dalla classe base \code{MonoBehaviour}, in modo da rendere possibile l'utilizzo delle funzioni evento associate ad essa. Ad ogni frame, Unity scorre tutti gli script attivi in scena, e se trova una di queste funzioni predefinite, la chiama (passando quindi il controllo alla funzione). Al termine dell'esecuzione, il controllo viene restituito a Unity.

Nelle prossime sezioni verranno analizzati alcuni degli script creati per le gestione delle componenti di gioco con cui l'utente può interagire durante una partita (\ref{sec:threat}, \ref{sec:ai}, \ref{sec:interactivesprite}) e quelli utilizzati per gestire la logica di gioco (\ref{sec:manager}), il salvataggio dei dati (\ref{sec:gamesaves}) e l'analisi delle prestazioni del giocatore (\ref{sec:analysis}).

\subsection{\code{InteractiveSprite} e \code{IObjectListener}}\label{sec:interactivesprite}

Questo script è associato a tutti gli oggetti della scena con cui il giocatore può interagire (fig. \ref{fig:interactiveImage}). Esegue diverse funzioni, in base agli eventi che hanno luogo durante lo svolgimento della partita. La prima avviene in automatico ad ogni avvio del gioco. Questo è possibile grazie al metodo \code{Start}, eseguito all'attivazione dell'oggetto a cui lo script è associato. Di norma il metodo è utilizzato per impostare uno stato iniziale. In questo caso, sono eseguiti dei controlli per impostare alcune variabili e, soprattutto, per stabilire se l'oggetto deve essere attivato o meno. 

Inizialmente, infatti, gli oggetti con cui è possibile effettuare delle azioni sono limitati nel numero. Per incrementarlo è necessario acquistare l'upgrade, specifico per ogni oggetto, dal negozio. Tramite il metodo \code{Start}, quindi, dopo aver impostato i valori di alcune variabili, si richiama il metodo \code{CheckOperativeItem}. Tramite esso si controlla il nome dell'oggetto, si ricava il numero massimo di quel tipo di oggetti che possono essere attivi in scena e, in base al confronto tra il valore del limite ed il numero associato ad ogni oggetto (sono denominati in maniera sequenziale, in modo da poter ricavare facilmente il numero dell'oggetto dal suo nome), viene deciso se renderlo interattivo o meno.

Un'altra serie di funzioni svolte nello script sono quelle che servono ad interagire effettivamente con l'oggetto. In questo caso vengono sfruttate le interfacce \code{IPointerUpHandler}, \code{IPointerDown-} \code{Handler}, \code{ IPointerEnterHandler}, \code{IPointerExitHandler} e \code{IPointerClickHandler} che permettono l'implementazione dei corrispettivi metodi \code{OnPointerUp}, \code{OnPointerDown}, \code{OnPointerEnter}, \code{OnPointerExit} e \code{OnPointerClick} utilizzati per gestire le interazioni dell'oggetto con il puntatore del mouse. Queste funzioni rimangono inizialmente in attesa e sono eseguite a seguito di un particolare evento del mouse. Nello specifico, le azioni controllate in questo caso sono il click, l'ingresso del cursore all'interno dell'immagine dell'oggetto e la sua uscita. 

Allo scatenarsi dei citati eventi, lo script svolge due azioni: la prima consiste nel cambio dell'immagine associata all'oggetto, in modo da dare l'impressione del click su di un pulsante. La seconda prevede la comparsa del menù contestuale associato all'oggetto, specifico per ognuna delle categorie di \code{InteractiveSprite}. Il menù è composto semplicemente da dei pulsanti, denominati nel codice come \code{ActionButton}, tanti quante sono le azioni effettuabili con l'oggetto selezionato. È necessario, però, impostare anche i \code{Listener} per ognuno di essi, in modo da permettere lo svolgimento effettivo delle azioni proposte. Per agevolare questa procedura, si è ricorso all'utilizzo di un'interfaccia, denominata \code{IObjectListener} che, come si può veder in \ref{fig:iobjectinterface}, prevede l'implementazione di un unico metodo, \code{SetListeners}. Per ogni categoria degli oggetti (\code{Telephone}, \code{ServerPc}, \code{RoomPc} e \code{Security}) è stato implementato uno script apposito, derivato dall'interfaccia \code{IObjectListener}. In questo modo, al click del mouse, è possibile richiamare il metodo \code{SetListeners} esposto tramite l'interfaccia, senza la necessità di conoscere su quale oggetto si sta cliccando (vedi fig. \ref{fig:setobjectlistener}).
 
\begin{figure}
\centerline{\includegraphics[scale=0.3]{Immagini/interactiveImage}}
\caption{ Screenshot dello scenario di gioco. Le \code{InteractiveSprite} sono facilmente riconoscibili grazie al bordo verde che le circonda.\label{fig:interactiveImage}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
// Start is called before the first frame update
private void Start()
{
    manager = SetLevelManager();

    interactiveSprite = GetComponent<SpriteRenderer>();
    boxCollider2D = GetComponent<BoxCollider2D>();

    //get the real name fo the sprite without the index. necessary in order to swap the sprite
    int pos = interactiveSprite.sprite.name.IndexOf("_", StringComparison.Ordinal);
    realName = interactiveSprite.sprite.name.Substring(0, pos);

    spriteMaxIndex = Resources.LoadAll<Sprite>(Path.Combine(StaticDb.rscIntSpriteFolder, realName)).Length - 1;

    //SET OPERATIVE
    CheckOperativeItem();
}
\end{lstlisting}
\HRule
\caption{Metodo \code{Start} della classe \code{InteractiveSprite}.\label{fig:interactiveStart}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
interface IObjectListener
{
    void SetListeners();
}
\end{lstlisting}
\HRule
\caption{Codice dell'interfaccia \code{IObjectInterface}.\label{fig:iobjectinterface}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
private void SetObjectListener()
{
    IObjectListener objectListener = gameObject.GetComponent<IObjectListener>();

    objectListener.SetListeners();
}
\end{lstlisting}
\HRule
\caption{Metodo \code{SetObjectListener} implementato nello script \code{InteractiveSprite}.\label{fig:setobjectlistener}}
\end{figure}

\subsection{\code{Threat}}\label{sec:threat}

Con la classe \code{Threat} si va a definire il codice relativo alle minacce da cui difendersi. Queste istanze vengono create periodicamente dal \code{LevelManager} in maniera casuale (per ulteriori spiegazioni vedere \ref{sec:manager}}, per poi essere associate al \code{GameObject} di un \code{AI} (vedi \ref{sec:ai}).

La classe \code{Threat} presenta diverse proprietà (fig. \ref{fig:threatclass}) esposte qui di seguito più nel dettaglio:

\begin{itemize}

\item \code{id}, int utilizzato per identificare in maniera univoca ogni nuova \code{Threat} generata. È assegnato al momento della creazione di una nuova \code{Threat} ed è incrementato in maniera sequenziale;

\item \code{threatType}, enum creato per identificare il tipo di \code{Threat} e può assumere uno tra cinque valori predefiniti. Questi sono \code{local},\code{remote},\code{fakeLocal},\code{hybrid} e \code{timeEvent}. Ognuno di essi contraddistingue un tipo di minaccia diverso, ad esempio \code{local} è utilizzato per gli attacchi che vengono effettuati dall'interno dell'azienda mentre \code{remote} per quelli condotti dall'esterno;

\item \code{deployTime}, valore che identifica il tempo (in termini di gioco) necessario perché l'attacco venga effettuato. Si può considerare anche come il tempo a disposizione del giocatore per evitare di subire quella minaccia;

\item \code{threatAttacker}, enum utilizzato per distinguere la tipologia dell'attaccante. Può assumere i valori di \code{internal}, utilizzato per gli attacchi effettuati da dipendenti corrotti interni all'azienda, \code{external}, con cui si identificano i normali attaccanti, e \code{timeEvent}, utilizzato per identificare le minacce associate ai \code{TimeEvent} generici (vedi\ref{sec:timeevent});

\item \code{threatDanger}, enum che definisce il livello di pericolosità della minaccia. In particolare, viene utilizzato per simulare il tentativo di corruzione nei confronti di un impiegato dell'azienda. Se il livello di pericolosità della minaccia è più alto del grado di resistenza del dipendente si subirà l'attacco, altrimenti verrà fermato;

\item \code{threatAttack}, enum che identifica quale tipo di attacco è associato alla nuova \code{Threat} generata. I valori che definiscono gli attacchi sono i seguenti: \code{dos}, \code{phishing}, \code{replay}, \code{mitm}, \code{stuxnet}, \code{dragonfly}, \code{malware}, \code{createRemote}, \code{fakeLocal} e \code{timeEvent}. I primi sette, come si evince dai nomi dati, identificano tipi di attacchi reali, \code{createRemote} è utilizzato per gli attacchi \code{local} al cui termine però non viene effettuato alcun attacco, ma se ne genera uno di tipo \code{remote}, \code{fakeLocal} identifica le attività locali legittime (inizialmente era utilizzato per identificare degli attacchi finti, successivamente, dopo aver cambiato le modalità con cui è effettuato un attacco si è riutilizzata la definizione per le attività locali delle AI che generano profitti) e \code{timeEvent}, infine, è associato alle minacce utilizzate per i \code{TimeEvent} generici (vedi\ref{sec:timeevent});

\item \code{fromCreateRemote}, bool utilizzato per identificare quelle minacce \code{remote} che hanno avuto origine da un attacco \code{createRemote} (è necessario per mostrare successivamente il messaggio relativo a questo tipo di attacco); 

\item \code{aiController} e \code{serializableAiController}, proprietà entrambe utilizzate per salvare le informazioni relative all'\code{AI} associata alla \code{Threat} generata. Sono utilizzate entrambe, nonostante rappresentino sostanzialmente la stessa variabile, in quanto di \code{aiController}, un'istanza dello script responsabile del controllo delle \code{AI} (vedi \ref{sec:ai}), non è possibile effettuare la serializzazione in fase di salvataggio. Viene, quindi, sostituita dalla classe \code{serializableAiController} con cui vengono salvat i valori delle proprietà di \code{aiController}, permettendone successivamente il ripristino in fase di caricamento della partita (vedi \ref{sec:gamesaves}.

\end{itemize}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
public class Threat
{
    public int id;
    public StaticDb.ThreatType threatType;
    public float deployTime; //expressed in hour
    public StaticDb.ThreatAttacker threatAttacker;
    public StaticDb.ThreatDanger threatDanger;
    public StaticDb.ThreatAttack threatAttack;
    public float moneyLossPerMinute;
    public bool fromCreateRemote;

    //values for ai controller prefab; the serializable one is created when game is saved
    public AiController aiController;
    public SerializableAiController serializableAiController;
}
\end{lstlisting}
\HRule
\caption{Proprietà della classe \code{Threat}.\label{fig:threatclass}}
\end{figure}

\subsection{\code{TimeEvent}}\label{sec:timeevent}

Un'altra classe di particolare importanza è quella dei \code{TimeEvent}, responsabile della definizione di tutti gli eventi a tempo che possono avvenire durante la partita. Tra questi vengono annoverate le \code{Threat}, ma anche tutti gli eventi a tempo che sono effettuabili tramite gli oggetti. Le proprietà (visibili in fig. \ref{fig:timeeventclass}), sono:

\begin{itemize}

\item \code{id}, int che identifica in maniera univoca ogni \code{TimeEvent}. È incrementato sequenzialmente ad ogni evento generato;

\item \code{duration}, float che esprime, in termini di tempo di gioco, la durata di un evento. Se l'evento è associato ad una \code{Threat}, coincide con il valore di \code{deployTime};

\item \code{percentagePerMin}, float, calcolato al momento della generazione dell'evento, che esprime il progresso percentuale compiuto ogni minuto;

\item \code{currentPercentage}, float che esprime l'attuale percentuale di completamento dell'evento;

\item \code{progressBar}, riferimento al \code{Canvas} utilizzato per rappresentare la barra di progresso associata all'evento;

\item \code{visible}, bool con il quale si definisce la visibilità della barra di progresso (alcuni eventi a tempo, come le minacce da remoto, non sono visibili e necessitano l'occultamento della barra di progresso);

\item \code{threat}, la \code{Threat} associata all'evento. Se il \code{TimEvent} generato è una nuova minaccia, questa proprietà imposterà tutti i valori specificamente per il tipo di minaccia generata, altrimenti verranno utilizzati valori standard per ogni proprietà della minaccia, in modo da renderla identificabile dalle reali \code{Threat} in corso di svolgimento;

\item \code{stoppable}, bool con cui si identifica se il \code{TimeEvent} possa essere fermato dall'utente o meno;

\item \code{progressBarParentName}, stringa per memorizzare il nome dell'oggetto a cui è attaccata la \code{progressBar};

\item \code{routine}, stringa utilizzata per memorizzare la routine da eseguire al termine del completamento del \code{TimeEvent}. È utilizzata al momento del ripristino degli oggetti dopo il caricamento di una partita (vedi \ref{sec:gamesaves}).

\end{itemize}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
public class TimeEvent
{
    public int id;
    public float duration; //expressed in minute
    public float percentagePerMin;
    public float currentPercentage;
    public Canvas progressBar;
    public bool visible;
    public Threat threat;
    public bool stoppable;
    public string progressBarParentName;
    public string routine;
}
\end{lstlisting}
\HRule
\caption{Proprietà della classe \code{TimeEvent}.\label{fig:timeeventclass}}
\end{figure}

\subsection{\code{AI}}\label{sec:ai}

Le \code{AI} sono dei prefab utilizzati per rappresentare nella scena del gioco i personaggi umani, ossia i dipendenti interni dell'azienda e gli attaccanti che tentano di camuffarsi tra loro. I prefab sono dei \code{GameObject} di Unity che è possibile salvare, insieme a tutte le componenti e le proprietà necessarie. In questo modo è possibile utilizzarli in un secondo momento come template per creare delle istanze nella scena del \code{GameObject} in questione.

Come si può vedere in \ref{fig:aiprefab}, il prefab utilizzato per le \code{AI} comprende diverse componenti, tutte dipendenti tra di loro al fine di garantirne il corretto funzionamento. Alcune di esse sono delle componenti base di Unity, necessarie affinché il \code{prefab} sia visibile e possa interagire sia con le azioni dell'utente che con le altre componenti presenti nella scena. Tra queste componenti si possono annoverare\code{Rigidbody 2D}, \code{Box Collider 2D}, \code{Animator}, \code{Sprite Renderer}, \code{Canvas Renderer} e \code{Canvas Group}.

Le rimanenti tre componenti, invece, sono state implementate appositamente per asserire alle funzionalità di gestione del \code{prefab}, animazione e risposta agli input del giocatore d. In particolare:

\begin{itemize}

\item \code{AiController} è la classe responsabile per la gestione generale del prefab. Tramite questo script sono effettuate le azioni del movimento nella scena dell'oggetto, oltre ad un serie di funzioni di controllo relative alla partita in corso. Il movimento è gestito in tre fasi: durante la creazione di una nuova istanza del \code{prefab} viene impostato un oggetto della scena come obiettivo da raggiungere al termine del \code{TimeEvent} associato all'\code{AI}. Dopodiché viene creata una destinazione temporanea da raggiungere, situata in un intorno dell'obiettivo (l'intorno ha un raggio che si restringe con il progredire del \code{TimEvent} associato). Una volta creata la destinazione temporanea, viene calcolato se è raggiungibile, tramite un algoritmo di pathfinding. Se il calcolo dà un riscontro positivo, fornendo un percorso da seguire, lo script inizia a spostare la posizione dell'oggetto verso la destinazione, seguendo il percorso fornito precedentemente, e, contemporaneamente, imposta l'immagine da visualizzare dallo script responsabile dell'animazione (\code{SpriteSheet Animator}). Una volta raggiunta la sua destinazione, o nel caso in cui l'algoritmo di pathfinding non si riuscito a trovare un percorso, l'\code{AI} viene fermata per alcuni secondi, prima di rieseguire le precedenti azioni.

La routine di movimento continuerà fin quando il \code{TimeEvent} associato all'\code{AI} non sarà completato. Nell'istante in cui ciò avviene, è impostato un flag con cui si dà il via all'esecuzione della routine che porterà alla distruzione del \code{prefab}. Viene fornita una destinazione (corrispondente al punto della mappa in cui inizialmente sono create) e, al suo raggiungimento, il \code{prefab} viene eliminato dalla scena, permettendo il rilascio delle risorse grafiche utilizzate.

\item \code{AiListener} è lo script in cui sono definite le azioni che è possibile effettuare con le \code{AI} presenti in scena. In particolare, tramite \code{Ai Controller} sono implementati i metodi per abilitare l'interazione del \code{prefab} con gli input dell'utente (come è stato fatto per le \code{InteractiveSprite} viste in precedenza in \ref{sec:interactivesprite}). Anche in questo caso, una volta effettuato un click sull'immagine di una \code{AI}, si aprirà il menù con i pulsanti relativi alle azioni che si possono svolgere. I metodi artefici di queste azioni sono racchiusi, appunto, all'interno della classe \code{AiListener}.

\item \code{SpriteSheet Animator} è la classe con cui è resa possibile l'animazione delle \code{AI}. Dato che le immagini relative al \code{prefab} sono scelte casualmente al momento della creazione, creare per ognuna di esse un'animazione specifica avrebbe richiesto molto tempo. Inoltre ciò avrebbe reso necessario la costruzione di \code{prefab} multipli per la \code{AI} (uno per ogni personaggio che si vuole raffigurare). Per questo si è deciso di tentare un approccio più elastico, che potesse essere applicato con facilità al caso in questione e rimanesse valido anche in caso di eventuali futuri sviluppi.

Il metodo attualmente in uso prevede l'utilizzo di un \code{Animator} in cui sono creati due stati, \code{Idle}, relativo a quando il personaggio è fermo, e \code{Walk}, per i movimenti dell'\code{AI}. Per ognuno degli stati sono state programmate otto animazioni, grazie all'utilizzo dei \code{Blend Trees} messi a disposizione dall'editor di Unity. I \code{Blend Trees} sono uno strumento che permette di miscelare animazioni multiple. tramite l'utilizzo di un parametro numerico. In questo caso sono stati sfruttati per riprodurre le animazioni in base alla direzione di cammino (e di arresto) del personaggio: otto, infatti, sono le direzioni lungo cui una \code{AI} può muoversi (nord, sud, est, ovest e quelle intermedie tra queste quattro). Quindi, durante lo spostamento del personaggio, viene calcolata la direzione e il \code{Blend Tree} permette la visualizzazione dell'animazione corretta. Questo, però, non è sufficiente per risolvere completamente il problema, dato che persiste la questione legata alle differenti immagini di cui riprodurre l'animazione. Per ovviare a ciò, è stata sfruttata la possibilità di creare delle animazioni in cui ad ogni cambio di frame viene eseguito un metodo. Nel caso in questione inizialmente si procede ad identificare il gruppo di immagini da riprodurre, partendo dal nome dell'immagine iniziale. Una volta effettuata l'identificazione, si procede con il caricare ognuna delle immagini in un array. Successivamente, tramite il metodo richiamato dall'\code{Animator} ad ogni frame, si indica quale visualizzare specificandone l'indice dell'array.

La soluzione adottata è stata creata ad hoc per il set di immagini con cui deve interagire. I diversi set, infatti, presentano tutte lo stesso numero immagini, disposte secondo le stesse modalità. Una volta importati nell'editor di Unity, grazie allo \code{Sprite Editor} è stato possibile dividere ogni set, creando singole immagini indicizzate in maniera sequenziale. Dato che ad ogni valore dell'indice corrisponde lo stesso tipo di immagine da visualizzare, è stato semplice arrivare alla soluzione attualmente in uso. In figura \ref{fig:aiSpriteImage} è possibile vedere un esempio dei diversi set di immagini utilizzate.

\end{itemize}

\begin{figure}
\centerline{\includegraphics[scale=0.3]{Immagini/aiImage}}
\caption{ Screenshot del prefab utilizzato per le \code{AI}. Sulla destra si possono notare le varie componenti utilizzate per il prefab, tra cui gli script \code{AiController} e \code{AiListener}, utilizzati per gestire i movimenti e le azioni delle \code{AI}.\label{fig:aiprefab}}
\end{figure}

\begin{figure}
\centerline{\includegraphics[scale=0.3]{Immagini/aiSpriteImage}}
\caption{ Esempio di set di immagini utilizzate per le \code{AI}.\label{fig:aiSpriteImage}}
\end{figure}

\subsection{\code{LevelManager} e \code{ILevelManager}}\label{sec:manager}

Gli script analizzati fin'ora sono quelli implementati per il controllo di singoli elementi di gioco, ma, affinché tutto queste componenti possano interagire tra di loro in maniera ordinata e controllata, è necessario di uno script d gestione globale. Da questo bisogno si è arrivati alla creazione del \code{LevelManager} e della relativa interfaccia di classe \code{ILevelManager}.

Il \code{LevelManager} è il vero nucleo del gameplay, senza di cui il gioco non sarebbe nemmeno utilizzabile. Al suo interno sono svolte diverse funzioni di creazione, gestione degli elementi di gioco e controllo dei dati relativi alla partita in corso di svolgimento. Tra le più significative si annoverano:

\begin{itemize}

\item metodi per la simulazione e gestione temporale, fondamentali per la gestione dei \code{TimeEvent}. Tramite queste funzioni, gli eventi a tempo possono essere completati e le azioni per cui sono stati creati possono essere eseguite. Inoltre, correlato alla simulazione temporale vi è anche la creazione e gestione delle minacce. Ogni \code{Threat} viene generata con una cadenza temporale variabile nel corso del gioco. Sia la creazione di una nuova minaccia che la frequenza con cui ciò avviene sono gestite dal \code{LevelManager} (vedi \ref{fig:levelmanagernewthreat});

\item legate alla creazione della minaccia, all'interno del \code{LevelManager} sono contenuti anche i metodi necessari per la loro gestione. In particolare le funzioni \code{BeforeDeployThreat}, \code{DeployThreat} e \code{AfterDeploThreat}, che gestiscono rispettivamente ciò che avviene prima, durante e dopo il concretizzarsi di un attacco. Nel primo metodo sono svolti dei controlli per accertare che la minaccia possa essere concretizzata in un attacco, in base anche alle caratteristiche del tipo di \code{Threat} in questione. Se il riscontro è negativo, viene richiamato il metodo per mostrare il messaggio corrispondente, la minaccia è tolta dalla coda degli eventi ed il \code{prefab} eliminato dalla scena. In caso positivo, invece, viene richiamato il metodo \code{DeployThreat} in cui, sempre in base al \code{ThreatType} vengono effettuate le azioni specifiche per concretizzare l'attacco. Una volta fatto ciò (e mostrato anche il messaggio all'utente che lo notifica di un attacco avvenuto), viene eseguito il metodo \code{AfterDeployThreat}, in cui sono aggiornati i valori relativi alle statistiche di gioco (attacchi ricevuti, numero di dipendenti e  reputazione del giocatore).Il metodo è richiamato anche in caso di attacco non andato a segno, ma chiaramente i valori saranno aggiornati tenendo conto del mancato attacco;

\item una volta subito un attacco, il giocatore dovrà intraprendere determinate azioni, a seconda del tipo, attraverso gli oggetti presenti in gioco (le \code{InteractiveSprite} analizzate in \ref{sec:interactivesprite}). I metodi relative alle azioni sono contenute nei \code{IObjectListener} di ogni oggetto, ma al fine della raccolta dati, nel \code{LevelManager}, durante questa fase, viene eseguito il metodo \code{ThreatManagementResultData} con cui si analizzano le mosse del giocatore, per capire come sta procedendo per risolvere la situazione di crisi dovuta all'attacco. Questo aspetto verrà approfondito in \ref{sec:analysis};

\item un'altra serie di metodi, legata sempre al gameplay, sono quelli necessari per attivare le difese (firewall, IDS e sicurezza locale) in grado di prevenire gli attacchi. Queste sono attivabili tramite gli oggetti in scena, ma il loro codice di controllo è stato inserito nel \code{LevelManager} poiché agiscono sulle variabili di gioco definite al suo interno. In particolare, effettuano dei controlli sulle code di minacce attive e, nel caso in cui abbiano successo lanciano un messaggio all'utente. La probabilità di efficacia delle componenti è fissa e può essere incrementata tramite gli acquisti del negozio, tuttavia il controllo in sé consiste nel confronto tra il suddetto valore e un numero calcolato casualmente. Se il numero è più alto della probabilità l'attacco non viene intercettato, altrimenti la difesa ha avuto successo e si procede con l'informare l'utente.

\end{itemize}

Tutti i metodi appena analizzati, oltre a diversi altri non elencati ma che svolgono funzioni di supporto nelle azioni elencate, sono implementati in ogni \code{LevelManager}. Per rendere possibile il loro utilizzo anche da classi esterne, senza ogni volta dover effettuare controlli su quale livello si sta giocando per recuperare la giusta istanza del corretto \code{LevelManager}, si è fatto utilizzo anche in questo caso di un'interfaccia, \code{ILevelManager}. In essa sono definiti tutti i metodi che devono essere presenti in un \code{LevelManager} affinché la partita si svolga correttamente. In questo modo la procedura per richiamare un metodo da una classe esterna risulta più veloce in quanto è sufficiente ottenere l'istanza dell'interfaccia, invece di quella della classe specifica (vedi fig. \ref{fig:setlevelmanager}). Inoltre, essendo definiti al suo interno tutti i metodi necessari affinché la partita si svolga in maniera corretta, risulta più semplice aggiungere dei nuovi livelli al gioco. Per questo punto si rimanda alla sezione \ref{sec:addlevel}.

\begin{figure}[tb]
\HRule
\begin{lstlisting}

gameData.threatSpawnRate = gameData.threatSpawnBaseTime / (float) gameData.totalEmployees;

public IEnumerator CreateNewThreat()
{
    //yield return new WaitForSeconds(5);
    for (;;)
    {
        gameData.threatSpawnTime = 0;

        yield return new WaitUntil(() => gameData.threatSpawnTime > gameData.threatSpawnRate);

        yield return new WaitWhile(() => gameData.hasThreatDeployed);

        NewThreat();
    }
}
\end{lstlisting}
\HRule
\caption{Metodo per la creazione di una nuova minaccia. Nella prima riga di codice è possibile vedere la definizione della frequenza con cui le minacce sono create.\label{fig:levelmanagernewthreat}}
\end{figure}

\begin{figure}[tb]
\HRule
\begin{lstlisting}
    private ILevelManager SetLevelManager()
    {
        ILevelManager iManager;
        if (SceneManager.GetActiveScene().buildIndex == StaticDb.level1SceneIndex)
            iManager = FindObjectOfType<Level1Manager>();
        else
            iManager = FindObjectOfType<Level2Manager>();

        return iManager;
    }
\end{lstlisting}
\HRule
\caption{Metodo con cui si richiama l'istanza dell'interfaccia \code{ILevelManager} nelle classi esterne. Utilizzando la variabile \code{iManager} è possibile richiamarne i metodi.\label{fig:setlevelmanager}}
\end{figure}

\subsection{Script per il salvataggio} \label{sec:gamesaves}

Come in tutti i giochi, è presente durante la partita la possibilità di salvare i dati, interrompendola, per poi continuare in un secondo momento. I file dei dati salvati sono mantenuti nel server, all'interno della cartella creata per ogni giocatore. Al fine di inviare le informazioni sulla partita in maniera veloce e in un formato facilmente gestibile, si è scelto di fare ricorso, nuovamente, alla classe di Unity \code{JsonUtility}, serializzando tutto in un unico file json da inviare al server. Per rendere questo processo ancora più veloce e semplice da eseguire, è stato deciso di implementare una classe, denominata \code{GameData}, al cui interno sono contenuti i valori di tutte le variabile relative al gioco:
\begin{itemize}
\item liste dei \code{TimeEvent} e delle \code{Threat} in corso di svolgimento;

\item flag relativi agli stati delle difese (attivate o disattivate);

\item valori relativi a data, soldi a disposizione, minacce sventate, minacce subite e altre statistiche del gioco;

\item flag con cui registrare l'acquisto di determinati potenziamenti dal negozio;

\item valori necessari per il corretto ripristino dei \code{prefab} al momento del caricamento di una partita.

\end{itemize}

Tutti questi valori sono di tipo primitivo, in modo da poter essere serializzati correttamente in un file json. Sono presenti anche variabili di tipo complesso e/o personalizzato (come ad esempio la lista dei \code{TimeEvent} in corso di svolgimento), ma si è potuto utilizzarle perché anch'esse, a loro volta, sono state rese possibili da serializzare.

I metodi per il salvataggio ed il caricamento del gioco sono contenuti nella classe \code{GameDataManager} e sono richiamati due classi esterne, risepttivamente \code{PauseManager}, ossia lo script utilizzato per mettere in pausa il gioco e da cui è possibile caricare il menù iniziale, e \code{LevelManager}. In quest'ultima, infatti, è presente il campo dell'istanza di \code{GameData} utilizzato per memorizzare i valori del livello in corso di svolgimento. Al momento del salvataggio, è richiamato il metodo \code{SaveLevelGameData} in cui si copiano i dati dell'istanza di \code{GameData} in una variabile locale. Successivamente vengono impostati i valori di tutti i \code{SerializableAiController}, partendo da quelli degli \code{AiController} presenti in scena, in modo da poter ripristinare durante il caricamento i corretti \code{prefab} dei personaggi. Svolto questo passaggio, si procede con al serializzazione del valore locale di \code{GameData} e, sfruttano la classe \code{UnityWebRequest}, viene effettuata una richiesta web indirizzandola allo script php contenuto nel server responsabile per la gestione dei dati di gioco. Quando la procedura termina, il giocatore è rimandato nel menù principale.

Per quanto riguarda il caricamento, la procedura applicata è sostanzialmente l'inversa di quella vista per il salvataggio. Non appena viene caricato il livello di gioco, il \code{LevelManager} richiama il metodo \code{LoadLevelGameData}. Qui viene subito effettuata una richiesta online indirizzata al server per ottenere una copia del file json presente al suo interno. Se la richiesta ha successo, si effettua prima un controllo sui dati ricevuti, per prevenire errori successivi che possono presentarsi al momento della deserializzazione. Se il controllo ha successo, i dati sono deserializzati e salvati una istanza locale di \code{GameData}. I valori della variabile vengono successivamente assegnati all'istanza di \code{GameData} implementata nel \code{LevelManager} che, una volta riottenuto il controllo, procede a ripristinare tutti i \code{prefab} e le variabili della partita in modo da permetterne il proseguimento. Questa procedura è eseguita ogni volta che viene avviata una partita. Se si tratta del primo avvio di un determinato livello, per evitare di creare inavvertitamente dei \code{prefab} errati ed utilizzare dei valori sbagliati dell'istanza di \code{GameData}, il \code{LevelManager} utilizza un flag che permette di distinguere se si tratta di una nuova od una vecchia partita da caricare. In caso affermativo, inizializza l'istanza di \code{GameData} con i valori predefiniti e fa cominciare la partita, mostrando il messaggio di benvenuto.

\subsection{Script per l'analisi delle prestazioni del giocatore} \label{sec:analysis}

Ai fini di poter analizzare la partita del giocatore, e stabilire se sta effettivamente apprendendo i concetti inseriti nel gioco, sono stati implementati degli script per poter monitorare le azioni dell'utente sia quando si trova a fronteggiare le conseguenze di un attacco, sia nei momenti di attesa in cui deve applicare una tattica di prevenzione da nuove minacce. Per quanto riguarda la prima situazione, si è deciso di monitorare i tempi con cui il giocatore reagisce ad un attacco subito, registrando anche le azioni intraprese in quel lasso temporale. Questi dati sono poi salvati in un file di log presente nel server, in modo da poterlo analizzare in un secondo momento. La statistica relativa ai tempi di risposta è resa disponibile anche al giocatore, tramite un grafico in cui sono raccolti i valori registrati nel corso della partita e che può essere visionato in qualsiasi momento durante lo svolgimento del gioco. Il motivo per cui si è deciso di analizzare la statistica dei tempi si basa sull'idea che, se il giocatore sta apprendendo in maniera corretta le lezioni, l'andamento generale delle curve dei tempi sarà in diminuzione con il passare del numero di attacchi fronteggiati. Inoltre, registrare le azioni effettuate nel lasso di tempo in questione permette di capire se il giocatore sta procedendo in maniera ragionata e specifica per il tipo di minaccia che sta affrontando o, più semplicemente, sta sta affidando al caso (in quest'ultima situazione le curve dei tempi di reazione avranno un andamento costante o, addirittura, in salita).

Per quanto riguarda, invece, l'analisi delle azioni di prevenzione attuate dal giocatore è stato necessario implementare una variabile che potesse essere d'aiuto in questo compito. Si è scelto, quindi, di implementare un trend delle minacce: all'avvio di una nuova partita viene scelta, casualmente, un tipo di minaccia che sarà più probabile subire rispetto alle altre. In particolare, al momento della creazione di una nuova minaccia, il tipo di \code{Threat} scelto per essere in trend avrà una probabilità di generazione del 60\% superiore rispetto agli altri tipi. Il trend delle minacce è poi ricalcolato ogni tre giorni (in termini di tempo di gioco), evitando che venga scelto di nuovo la stessa tipologia già presente in trend. Sfruttando questa dinamica è stato possibile implementare un metodo che analizzasse le azioni di prevenzione relativamente al trend del momento. In particolare, le azioni monitorate sono l'attivazione o disattivazione dei servizi di sicurezza (firewall, IDS e controlli locali), oltre agli acquisti di potenziamenti dal negozio (sfruttando la proprietà \code{ThreatAffinity} presente per ogni \code{ItemStore}, come esposto in \ref{sec:itemstore}. Il metodo di analisi viene richiamato ogni volta in cui è effettuata una delle azioni elencate precedentemente e, in base al trend del momento, ne dà una valutazione, registrandola all'interno del file di log presente nel server.

L'analisi delle azioni del giocatore può essere, ovviamente, ampliata e strutturata in maniera più dettagliata, ma per i fini del progetto e per questioni legate al tempo necessario per uno sviluppo più dettagliato, si è preferito fornire un'idea di cosa è possibile analizzare e in quale maniera. Per un approfondimento sul tema in questione si rimanda alla sezione \ref{sec:futuredevelop}.

\section{Come aggiungere un livello}\label{sec:addlevel}

Il gioco può essere ampliato, aggiungendo nuovi livelli, in modo da poter inserire nuove nozioni all'interno del gioco o, addirittura, creare livelli specifici per un tipo di minaccia in particolare, rendendo l'esperienza di gioco più focalizzata e differenziata. Per aggiungere un nuovo livello è possibile procedere da zero, creando una nuova scena al cui interno inserire i diversi \code{GameObject} con allegati gli script analizzati in precedenza. Ma, per evitare di incorrere in problemi durante l'esecuzione del gioco, legati alla mancanza di qualche componente, è consigliabile selezionare una delle scene relative ai due livelli già implementati e duplicarlo. In questo modo si avrà una nuova scena, su cui poter agire senza problemi. A questo punto è importante aprire i \code{Build Settings} del progetto (la voce è presente nel tab \code{File}). Una volta fatto click sulla voce, si aprirà una nuova finestra. Qui occorre inserire la scena appena creata all'interno del riquadro \code{Scenes In Build} (per farlo è sufficiente trascinare l'icona della scena dentro il riquadro). Una volta effettuato questo passaggio, 	sarà possibile notare che accanto al nome della scena sarà comparso un numero, corrispondente all'indice della scena stessa. Questo indice rappresenta il valore da utilizzare negli script di caricamento per poter permettere l'accesso alla nuova scena.

Come detto, si può agire su qualsiasi aspetto del gioco: 

\begin{itemize}

\item per modificare, ad esempio, la generazione delle minacce nel nuovo livello occorre creare un nuovo \code{LevelManager}, facendolo derivare dall'interfaccia \code{ILevelManager}. Successivamente è necessario implementare un nuovo metodo nella classe \code{ThreatManager}, riprendendo la struttura generale dei metodi \code{NewRandomLevel\#Manager} (con il numero del livello al posto di \#) già implementati e richiamarlo nel metodo \code{NewThreat} presente nel nuovo \code{LevelManager}. 

\item per aggiungere nuove azioni eseguibili tramite le \code{InteractiveSprite} è possibile agire sui singoli \code{Listener} di ogni categoria. Naturalmente, in questo caso, occorre tenere a mente che se si vuole agire su variabili di gioco presenti nella classe \code{GameData} è necessario recuperare i giusti valori tramite la corretta istanza presente nel \code{LevelManager}. Per fare ciò si può utilizzare il metodo riportato in \ref{fig:setlevelmanager}, aggiungendo eventualmente i casi relativi ai nuovi livelli implementati.

\item per implementare nuovi \code{ItemStore}, \code{Lesson} e \code{Message} è sufficiente seguire il pattern già esistente. In particolare è necessario un file json e un file txt con le caratteristiche fornite nei template e salvarli nelle relative cartelle (le cartelle sono denominate secondo il pattern NomeOggetto e NomeOggettoBody e raccolgono, rispettivamente, il file json dell'oggetto ed il file txt contenente il testo più lungo relativo al messaggio/lezio/descrizione dell'oggetto da acquistare). Successivamente, in base all'oggetto aggiunto, possono essere necessarie alcune ulteriori azioni. 

Nel caso dell'\code{ItemStore} sarà necessario aggiungere un nuovo \code{case} nello \code{switch} del metodo \code{ApplyItemEffect} relativo all'effetto che si vuole associare al nuovo potenziamento (il metodo è implementato all'interna dello script \code{StoreManager}). 

Nel caso di un messaggio, invece, è necessario aggiungere il metodo da richiamare per visualizzare il messaggio. Per fare ciò si può agire nello script \code{LevelMessageManager}, rispettando il pattern presentato negli altri casi: un metodo \code{public} con cui richiamare una \code{coroutine}. Il primo metodo sarà quello che verrà richiamato per dar via alla visualizzazione del messaggio, la quale avverrà grazie al secondo metodo. Questo è stato fatto perché trattandosi di \code{coroutine}, metodi la cui esecuzione può essere messa in pausa, si è cercato di rispettare i design pattern proposti dallo stesso manuale di Unity. 

Se invece è stata aggiunta una nuova lezione non c'è bisogno di ulteriori azioni. C'è però una precauzione da prendere in questo caso: per evitare che il gioco possa dare problemi di caricamento della lezione al momento della visualizzazione, è consigliato creare file txt non eccessivamente lunghi. Il rischio è quello di scatenare un'eccezione di tipo \code{OutOfMemory} nel browser, richiedendo il refresh della pagina web in cui il gioco è eseguito.

\end{itemize}

Per testare che le nuove funzionalità aggiunte vengano eseguite in maniera corretta, è possibile sfruttare il player nell'editor di Unity. In questo modo si possono effettuare test senza dover ogni volta creare una build. Nel momento in cui si vuole effettuare una build da caricare in un server occorre selezionare di nuovo la voce \code{Build Settings}, controllare che la scena sia selezionata all'interno del riquadro \code{Scenes In Build} e lanciare il build dell'applicativo finale.